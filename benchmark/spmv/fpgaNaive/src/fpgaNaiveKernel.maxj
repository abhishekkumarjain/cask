/*** Single pipe SpMV kernel. */

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;

import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.*;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.*;

class fpgaNaiveKernel extends Kernel {

    private static final int size = 32;
    private static final int vRomAddressSizeBits = MathUtils.bitsToAddress(size);

    protected fpgaNaiveKernel(KernelParameters parameters,
                              int fpL) {
        super(parameters);

        // --- design scalar inputs
        DFEVar n = io.scalarInput("n", dfeUInt(32));

        // --- control
        DFEVar cycleCount = control.count.simpleCounter(32);
        DFEVar flush = cycleCount >= n;
        DFEVar compute = cycleCount < n;

        // -- design dynamic inputs
        // ROM for storing the vector we are multiplying with
        Memory<DFEVar> vRom = mem.alloc(dfeFloat(11, 53), size);
        vRom.mapToCPU("vRom");

        // read in the matrix
        DFEVar value = io.input("value_in", dfeFloat(11, 53), compute);
        DFEVar indptr = io.input("indptr_in", dfeInt(32), compute).cast(dfeUInt(vRomAddressSizeBits)); // col ptr
        DFEVar rowFinished = io.input("rowEnd_in", dfeUInt(32), compute);

        // counter is set to 0 when row has finished
        // while counter is less than fpL, we can output results
        Params params = control.count.makeParams(32)
            .withReset(rowFinished)
            .withInitValue(fpL + 1);


        Counter rowCounter = control.count.makeCounter(params);

        // We need to start output the next cycle after the reset,
        // since the reset will happen before the end of the row and
        // we want to start outputing on the next cycle to allow the
        // correct result to proceed out of the pipeline
        DFEVar output = rowCounter.getCount() <= fpL & rowCounter.getCount() > 0;

        // --- compute
        DFEVar carriedSum = dfeFloat(11, 53).newInstance(this);
        DFEVar newSum = value * vRom.read(indptr) + (rowCounter.getCount() < fpL ? 0 : carriedSum);
        carriedSum <== stream.offset(newSum, -fpL);
        DFEVar reduced = constant.var(0);
        for (int i = 0; i < fpL; i++)
                 reduced = reduced + stream.offset(carriedSum, -i);

        debug.simPrintf("kernel: %f %d %d output = %f %f\n", 
                        value, indptr, rowFinished,
                        carriedSum, reduced);

        io.output("b", reduced, dfeFloat(11, 53), flush | output);
    }

}

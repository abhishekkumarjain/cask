/*** Single pipe SpMV kernel. */

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;

import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.*;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.*;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count;



class fpgaNaiveKernel extends Kernel {

    protected fpgaNaiveKernel(KernelParameters parameters,
                              int fpL,
                              int cacheSize,
                              boolean dbg) {
        super(parameters);

        int vRomAddressSizeBits = MathUtils.bitsToAddress(cacheSize);

        // --- control
        DFEVar cycleCount = control.count.simpleCounter(32);

        // ROM for storing the vector we are multiplying with
        Memory<DFEVar> vRom = mem.alloc(dfeFloat(11, 53), cacheSize);
        vRom.mapToCPU("vRom");

        DFEVar rowFinished = io.input("rowEnd_in", dfeUInt(32));
        DFEVar rowEmpty = rowFinished.eq(2);

        // -- I/O control
        DFEVar readInput = ~rowEmpty;
        DFEVar outputEnable = rowFinished.eq(1) | rowEmpty;

        // read in the matrix
        DFEVar value = io.input("value_in", dfeFloat(11, 53), readInput);
        DFEVar indptr = io.input("indptr_in", dfeInt(32), readInput).cast(dfeUInt(vRomAddressSizeBits)); // col ptr


        // counter is set to 0 when row has finished
        // while counter is less than fpL, we can output results
        Params params = control.count.makeParams(32)
            .withReset(stream.offset(rowFinished.cast(dfeUInt(1)), -1))
            .withMax(fpL - 1)
            .withWrapMode(Count.WrapMode.STOP_AT_MAX);

        DFEVar rowCounter = control.count.makeCounter(params).getCount();

        // --- compute
        DFEVar carriedSum = dfeFloat(11, 53).newInstance(this);
        DFEVar newSum = value * vRom.read(indptr) + (rowCounter < fpL ? 0 : carriedSum);
        carriedSum <== stream.offset(newSum, -fpL);

        DFEVar reduced[] = new DFEVar[fpL];
        reduced[0] = newSum;
        for (int i = 1; i < fpL; i++)
            reduced[i] = reduced[i - 1] + stream.offset(newSum, -i);

        DFEVar reducedOut = rowEmpty ? 0 : control.mux(rowCounter.cast(dfeUInt(4)), reduced);

        // for (int i = 1; i < fpL; i++)
        //     debug.simPrintf("reduced[%d] = %f, ", i, reduced[i]);

        if (dbg)
            debug.simPrintf("%3d - value: %f indptr: %3d rowFinished: %d carriedSum: %f reducedOut: %f rowCounter %d outputEnable %d  rowEmpty %d\n", 
                        cycleCount,
                        value, indptr, rowFinished,
                        carriedSum, reducedOut, 
                            rowCounter,
                            outputEnable,
                            rowEmpty
                            );

        io.output("b", reducedOut, dfeFloat(11, 53), outputEnable);
        // io.output("outputCycle", outputCycle, dfeUIn(32));
    }

}

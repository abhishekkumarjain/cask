    LUTs     FFs   BRAMs    DSPs : SpmvKernel.maxj
  105055  132726     614     192 : resources used by this file
  20.02%  12.65%  23.92%   9.78% : % of available
  58.95%  51.70%  47.30% 100.00% : % of total used
  98.74%  93.30%  99.68% 100.00% : % of user resources

                                 : import java.util.*;
                                 : 
                                 : import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
                                 : import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
                                 : import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.*;
                                 : import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.*;
                                 : import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
                                 : import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
                                 : import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.*;
                                 : import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.KernelMath;
                                 : import com.maxeler.maxcompiler.v2.utils.MathUtils;
                                 : 
                                 : import com.custom_computing_ic.dfe_snippets.utils.Reductions;
                                 : import com.custom_computing_ic.dfe_snippets.reductions.LogAddReduce;
                                 : import com.custom_computing_ic.dfe_snippets.utils.FetchSubTuple;
                                 : 
                                 : 
                                 : class SpmvKernel extends Kernel {
                                 : 
                                 :   // N x N matrix, nnzs nonzeros
                                 :   //
                                 :   // load data for N cycles into cache
                                 :   // compute for N cycles
                                 :   // -- in the mean time load data for N cycles in double buffer
                                 :   // repeat
                                 :   //
                                 :   // Sources of inefficiency:
                                 :   // -- empty rows
                                 :   // -- port sharing cannot be used
                                 : 
                                 :   private final DFEVectorType<DFEVar> vtype, ivtype;
                                 :   private final int inputWidth;
                                 :   private final DFEType addressT;
                                 :   private final boolean dbg;
                                 : 
                                 :   private static final int fpL = 16;
                                 : 
                                 :   protected SpmvKernel(
                                 :       KernelParameters parameters,
                                 :       int inputWidth,
                                 :       int cacheSize,
                                 :       int indexWidth,
                                 :       int mantissaWidth,
                                 :       boolean dbg) {
                                 :     super(parameters);
                                 : 
                                 :     optimization.pushPipeliningFactor(0.5);
                                 :     optimization.pushDSPFactor(1);
                                 : 
                                 : 
                                 :     this.inputWidth = inputWidth;
                                 :     this.addressT = dfeUInt(MathUtils.bitsToAddress(cacheSize));
                                 :     this.dbg = dbg;
                                 : 
                                 :     vtype = new DFEVectorType<DFEVar> (dfeFloat(11, mantissaWidth), inputWidth);
                                 :     ivtype = new DFEVectorType<DFEVar> (dfeUInt(indexWidth), inputWidth);
                                 : 
                                 :     // TODO: remove prefetch from this kernel
                                 : 
       1       2       0       0 :     DFEVar vRomLoadEnable = io.input("loadEnabled", dfeBool());
       1       0       0       0 :     DFEVector<DFEVar> matrixValues = io.input("matrixValues", vtype, ~vRomLoadEnable);
       1       1       0       0 :     DFEVector<DFEVar> vectorValues = io.input("vectorValues", vtype, ~vRomLoadEnable);
                                 : 
   65864   89061     127     192 :     DFEVar result = Reductions.reduce(matrixValues * vectorValues);
                                 : 
                                 :     // --- Accumulation
       1       2       0       0 :     DFEVar rowFinished = io.input("rowFinished", dfeBool());
       1       1       0       0 :     DFEVar rowLength = io.input("rowLength", dfeUInt(32));
       1       1       0       0 :     DFEVar cycleCounter = io.input("cycleCounter", dfeUInt(32));
       1       0       0       0 :     DFEVar firstReadPosition = io.input("firstReadPosition", dfeUInt(32));
                                 : 
      32      32       0       0 :     DFEVar runLength = firstReadPosition + rowLength;
     258     234       2       0 :     DFEVar modulo = KernelMath.modulo(runLength, inputWidth);
    1240     988      10       0 :     DFEVar quot = (runLength - modulo.cast(dfeUInt(32))) / inputWidth;
                                 : 
      33      51       0       0 :     DFEVar totalCycles = quot + (modulo === 0 ? constant.var(dfeUInt(32), 0) : 1);
                                 : 
                                 :     DFEVar carriedSum = dfeFloat(11, mantissaWidth).newInstance(this);
    1103    1177       3       0 :     DFEVar newSum = result + (cycleCounter < fpL ? 0 : carriedSum);
                                 :     carriedSum <== stream.offset(newSum, -fpL);
                                 : 
      41      65       0       0 :     DFEVar firstValidPartialSum = (totalCycles > fpL)? (totalCycles - fpL) : 0;
      25       1       0       0 :     DFEVar validPartialSums = (cycleCounter >= firstValidPartialSum);
    4654    5213       4       0 :     LogAddReduce r = new LogAddReduce(this,
                                 :         validPartialSums,
                                 :         rowFinished,
                                 :         newSum,
                                 :         dfeFloat(11, mantissaWidth),
                                 :         fpL);
                                 : 
                                 :     // TODO still need reduction step
                                 :     // TODO: remove prefetch
      10      12       1       0 :     DFEVar outputEnable = ~vRomLoadEnable & rowFinished;
       9       6       1       0 :     io.output("output", r.getOutput(), dfeFloat(11, mantissaWidth), outputEnable);
                                 : 
                                 :     // --- Debug
                                 :     if (dbg) {
                                 :         Params rowCounterParams = control.count.makeParams(32)
                                 :           .withEnable(rowFinished);
                                 :         DFEVar rowCounter = control.count.makeCounter(rowCounterParams).getCount();
                                 : /*      debug.simPrintf(
                                 :           rowLength !== 0,
                                 :           "Kernel -- row %d totalCycles %d, readenable %d, readmask %d rowFinished %d rowLength %d output: %f cycleCounter %d validPartialSums %d newSum %f firstRead %d",
                                 :           rowCounter, totalCycles, readEnable, readMask, rowFinished, rowLength, r.getOutput(), cycleCounter, validPartialSums, newSum, firstReadPosition);
                                 :       debug.simPrintf(rowLength !== 0 , " loadEnable %d loadAddress %d\n", vRomLoadEnable, loadAddress);
                                 : */
                                 :       //debug.simPrintf("\n");
                                 :       //debug.simPrintf("Values: ");
                                 :       //for (int i = 0; i < inputWidth; i++)
                                 :         //debug.simPrintf("%f ", values[i]);
                                 :       //debug.simPrintf("Indices: ");
                                 :       //for (int i = 0; i < inputWidth; i++)
                                 :         //debug.simPrintf("%d ", colptr[i]);
                                 :       //debug.simPrintf("\n");
                                 :     }
                                 :   }
                                 : 
                                 : }
                                 : 
                                 : // This implements cache as
                                 : //   - row of BRAMs
                                 : //   - SM, which helps to select BRAM values
                                 : class SpmvCacheKernel extends Kernel {
                                 : 
                                 :   private final DFEVectorType<DFEVar> vtype, ivtype;
                                 :   private final List<Memory<DFEVar>> vroms;
                                 :   private final int inputWidth;
                                 :   private final DFEType addressT;
                                 : 
                                 :   protected SpmvCacheKernel(KernelParameters parameters,
                                 :       int inputWidth,
                                 :       int cacheSize,
                                 :       int indexWidth,
                                 :       int mantissaWidth) {
                                 :     super(parameters);
                                 : 
                                 :     this.inputWidth = inputWidth;
                                 :     this.addressT = dfeUInt(MathUtils.bitsToAddress(cacheSize));
                                 : 
                                 :     // load entire vector or until cache is full
                                 :     int sizeBits = 32; // XXX may need to run for more cycles
                                 :     DFEVar vRomLoadEnable = io.input("loadEnabled_in", dfeBool());
                                 : 
                                 :     DFEVar vectorLoadCycles = io.scalarInput("vectorLoadCycles", dfeUInt(32));
                                 :     Params loadAddressParams = control.count.makeParams(sizeBits )
                                 :       .withMax(vectorLoadCycles)
                                 :       .withEnable(vRomLoadEnable);
                                 :     DFEVar loadAddress = control.count.makeCounter(loadAddressParams).getCount();
                                 : 
                                 : 
                                 :     vtype = new DFEVectorType<DFEVar> (dfeFloat(11, mantissaWidth), inputWidth);
                                 :     ivtype = new DFEVectorType<DFEVar> (dfeUInt(indexWidth), inputWidth);
                                 :     DFEVar vectorValue = io.input("vromLoad", dfeFloat(11, mantissaWidth), vRomLoadEnable);
                                 :      //--- Cache allocation and control
                                 :     vroms = new ArrayList<Memory<DFEVar>>();
                                 :     for (int i = 0; i < inputWidth; i++) {
                                 :       Memory<DFEVar> vrom = mem.alloc(dfeFloat(11, mantissaWidth), cacheSize);
                                 :       vroms.add(vrom);
                                 :       vrom.write(
                                 :           loadAddress.cast(addressT),
                                 :           vectorValue,
                                 :           vRomLoadEnable);
                                 :     }
                                 : 
                                 :     // --- I/O
                                 :     DFEVar readEnable = io.input("readenable", dfeBool()) & ~vRomLoadEnable;
                                 :     DFEVar readMask = io.input("readmask", dfeUInt(inputWidth));
                                 :     DFEVector<DFEVar> matrixValues = selectValues(
                                 :         io.input("values", vtype, readEnable),
                                 :         readMask);
                                 :     DFEVector<DFEVar> colptr = selectValues(
                                 :         io.input("indptr", ivtype, readEnable),
                                 :          readMask);
                                 :     DFEVector<DFEVar> vectorValues = resolveVectorReads(colptr);
                                 : 
                                 :     io.output("loadEnabled_out", vRomLoadEnable, dfeBool());
                                 :     io.output("matrixValues", matrixValues, vtype, ~vRomLoadEnable);
                                 :     io.output("vectorValues", vectorValues, vtype, ~vRomLoadEnable);
                                 :   }
                                 : 
                                 :   DFEVector<DFEVar> selectValues(
                                 :       DFEVector<DFEVar> in,
                                 :       DFEVar readMask) {
                                 :     DFEVector<DFEVar> out = in.getType().newInstance(this);
                                 :     for (int i = 0; i < in.getSize(); i++)
                                 :       out[i] <== readMask.slice(i) === 0 ?  0 : in[i];
                                 :     return out;
                                 :   }
                                 : 
                                 : 
                                 :   DFEVector<DFEVar> resolveVectorReads(DFEVector<DFEVar> reads) {
                                 :     DFEVector<DFEVar> out = vtype.newInstance(this);
                                 :     for (int i = 0; i < vroms.size(); i++)
                                 :       out[i] <== vroms.get(i).read(reads[i].cast(addressT));
                                 :     return out;
                                 :   }
                                 : 
                                 : }
                                 : 
                                 : // This implements cache as
                                 : //   - row of BRAMs
                                 : //   - FetchSubTuple
                                 : // First, rough and pointless implementation.
                                 : class SpmvCacheFSTKernel extends Kernel {
                                 : 
                                 :   private final DFEVectorType<DFEVar> vtype, ivtype;
                                 :   private final List<Memory<DFEVar>> vroms;
                                 :   private final int inputWidth;
                                 :   private final DFEType addressT;
                                 : 
                                 :   protected SpmvCacheFSTKernel(KernelParameters parameters,
                                 :       int inputWidth,
                                 :       int cacheSize,
                                 :       int indexWidth,
                                 :       int mantissaWidth) {
                                 :     super(parameters);
                                 : 
                                 :     this.inputWidth = inputWidth;
                                 :     this.addressT = dfeUInt(MathUtils.bitsToAddress(cacheSize));
                                 : 
                                 :     // load entire vector or until cache is full
                                 :     int sizeBits = 32; // XXX may need to run for more cycles
       1       1       0       0 :     DFEVar vRomLoadEnable = io.input("loadEnabled_in", dfeBool());
                                 : 
                                 :     DFEVar vectorLoadCycles = io.scalarInput("vectorLoadCycles", dfeUInt(32));
                                 :     Params loadAddressParams = control.count.makeParams(sizeBits )
                                 :       .withMax(vectorLoadCycles)
                                 :       .withEnable(vRomLoadEnable);
      94      78       0       0 :     DFEVar loadAddress = control.count.makeCounter(loadAddressParams).getCount();
                                 : 
                                 : 
                                 :     vtype = new DFEVectorType<DFEVar> (dfeFloat(11, mantissaWidth), inputWidth);
                                 :     ivtype = new DFEVectorType<DFEVar> (dfeUInt(indexWidth), inputWidth);
       1      65       0       0 :     DFEVar vectorValue = io.input("vromLoad", dfeFloat(11, mantissaWidth), vRomLoadEnable);
                                 :      //--- Cache allocation and control
                                 :     vroms = new ArrayList<Memory<DFEVar>>();
                                 :     for (int i = 0; i < inputWidth; i++) {
       1       1     336       0 :       Memory<DFEVar> vrom = mem.alloc(dfeFloat(11, mantissaWidth), cacheSize);
                                 :       vroms.add(vrom);
                                 :       vrom.write(
                                 :           loadAddress.cast(addressT),
                                 :           vectorValue,
                                 :           vRomLoadEnable);
                                 :     }
                                 : 
                                 :     // --- I/O
                                 :     // --- buffering matrix and colptr data in FST
                                 : 
                                 :     // assuming readEnable guards internal storage of FST from overflow:
                                 :     // 
                                 :     //    DFEVar dataRequestEnableLoop = dfeBool().newInstance(this);
                                 :     //    DFEVar dataRequestEnable = control.count.pulse(1)? 0
                                 :     //                               : stream.offset(dataRequestEnableLoop,-1);
                                 :     //    DFEVar enable = readEnable & dataRequestEnable;
                                 : 
       2       3       0       0 :     DFEVar readEnable = io.input("readenable", dfeBool()) & ~vRomLoadEnable;
       1       1       0       0 :     DFEVar readMask = io.input("readmask", dfeUInt(inputWidth));
                                 : 
       1    3803       0       0 :     DFEVector<DFEVar> matrix_in = io.input("values", vtype, readEnable);
       1       1       0       0 :     DFEVector<DFEVar> index_in = io.input("indptr", ivtype, readEnable);
                                 : 
                                 :     // big hack around: counting the number of 1s in readmask
                                 :     List<DFEVar> readmask_bits = new ArrayList<DFEVar>();
                                 :     for (int i = 0; i < inputWidth; i++)
                                 :     {
       0     529       0       0 :         readmask_bits.add(readMask[i].cast(dfeBool()).cast(dfeUInt(6))); // 2^6 = 64 > 48 = inputWidth
                                 :     }
     144     145       0       0 :     DFEVar numEntriesToRead = Reductions.reduce(readmask_bits);
                                 : 
                                 :     // we don't care which PE receives each entry (assume matrices are
                                 :     // numerically nice enough to change the order of accumulation)
                                 :     boolean alignOutput = false;
                                 :     int matrixTypeWidth = 11 + mantissaWidth;
                                 :     FetchSubTuple matrixBuffer = new FetchSubTuple(this, "matrix", inputWidth,
                                 :                                  matrixTypeWidth, dfeFloat(11, mantissaWidth),
                                 :                                  alignOutput);
                                 :     FetchSubTuple indexBuffer  = new FetchSubTuple(this, "index", inputWidth,
                                 :                                  indexWidth, dfeUInt(indexWidth), alignOutput);
                                 : 
   25403   25051       0       0 :     DFEVector<DFEVar> matrixValues = matrixBuffer.popPush(numEntriesToRead, readEnable, matrix_in);
    4753    4228       0       0 :     DFEVector<DFEVar> colptr = indexBuffer.popPush(numEntriesToRead, readEnable, index_in);
                                 : 
                                 :     //dataRequestEnableLoop <== matrixBuffer.nextPushEnable();
                                 :     
                                 :     DFEVector<DFEVar> vectorValues = resolveVectorReads(colptr);
                                 : 
                                 :     io.output("loadEnabled_out", vRomLoadEnable, dfeBool());
       0       5       0       0 :     io.output("matrixValues", matrixValues, vtype, ~vRomLoadEnable);
       1       2       0       0 :     io.output("vectorValues", vectorValues, vtype, ~vRomLoadEnable);
                                 :   }
                                 : 
                                 :   DFEVector<DFEVar> resolveVectorReads(DFEVector<DFEVar> reads) {
                                 :     DFEVector<DFEVar> out = vtype.newInstance(this);
                                 :     for (int i = 0; i < vroms.size(); i++)
                                 :       out[i] <== vroms.get(i).read(reads[i].cast(addressT));
                                 :     return out;
                                 :   }
                                 : 
                                 : }
                                 : 
                                 : 
                                 : 
                                 : 
                                 : // XXX for now we assume the matrix is smaller then max rows
                                 : // will have to implement an lmem design above this threshold
                                 : // using lmem wrapped above this thresholed may be feasilbe,
                                 : // see the DramAccumulator snippet in dfe-snippets
                                 : class SpmvReductionKernel extends Kernel {
                                 : 
                                 :   protected SpmvReductionKernel(KernelParameters parameters, int fpl, int maxRows) {
                                 :     super(parameters);
                                 : 
       1       1       0       0 :     DFEVar in = io.input("reductionIn", dfeFloat(11, 53));
                                 :     DFEVar n = io.scalarInput("nRows", dfeUInt(32));
                                 :     DFEVar totalCycles = io.scalarInput("totalCycles", dfeUInt(32));
                                 : 
      69     120       0       0 :     DFEVar cycles = control.count.simpleCounter(32);
                                 : 
                                 :     DFEVar sumCarried = dfeFloat(11, 53).newInstance(this);
    1116    1572       2       0 :     DFEVar sum = in + (cycles < n ? 0 : sumCarried);
      44      48     128       0 :     sumCarried <== stream.offset(sum, -(n.cast(dfeInt(32))), -maxRows, -(fpl + 2));
                                 : 
                                 :     // output on the last n cycles
      55      33       0       0 :     DFEVar outputEnable = totalCycles - cycles <= n;
       1      14       0       0 :     io.output("reductionOut", sum, dfeFloat(11, 53), outputEnable);
                                 :   }
                                 : }
                                 : 
                                 : 
                                 : class PaddingKernel extends Kernel {
                                 :   protected PaddingKernel(KernelParameters parameters) {
                                 :     super(parameters);
                                 :     DFEVar nInputs = io.scalarInput("nInputs", dfeUInt(32));
      69     107       0       0 :     DFEVar cycles = control.count.simpleCounter(32);
      20       1       0       0 :     DFEVar paddingCycles = cycles >= nInputs;
       1       1       0       0 :     DFEVar input = io.input("paddingIn", dfeFloat(11, 53), ~paddingCycles);
       0      69       0       0 :     DFEVar out = paddingCycles ? 0 : input;
                                 :     io.output("paddingOut", out, dfeFloat(11, 53));
                                 :   }
                                 : }
